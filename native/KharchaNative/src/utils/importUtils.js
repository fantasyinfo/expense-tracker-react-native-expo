import RNFS from 'react-native-fs';
import DocumentPicker from 'react-native-document-picker';
import { parseDate } from './dateUtils';
import { saveEntries, loadEntries } from './storage';

/**
 * Parse CSV content and convert to entries array
 */
export const parseCSV = (csvContent) => {
  try {
    const lines = csvContent.split('\n').filter(line => line.trim());
    
    const entries = [];
    let skippedCount = 0;
    let processedCount = 0;
    
    // Find the actual header row (skip report title and header notes)
    let headerIndex = -1;
    let header = '';
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      // Look for the actual CSV header row
      if (line.startsWith('Date,Type,Amount,Payment Method')) {
        header = line;
        headerIndex = i;
        break;
      }
    }
    
    // If header not found, try first line (for old format files)
    if (headerIndex === -1 && lines.length > 0) {
      header = lines[0].trim();
      headerIndex = 0;
    }
    
    // Support both old format (without Category) and new format (with Category)
    const expectedHeaderOld = 'Date,Type,Amount,Payment Method,Note';
    const expectedHeaderNew = 'Date,Type,Amount,Payment Method,Category,Note';
    
    const isOldFormat = header === expectedHeaderOld;
    const isNewFormat = header === expectedHeaderNew;
    
    // Skip header row and summary rows (start from line after header)
    const startIndex = headerIndex >= 0 ? headerIndex + 1 : 1;
    for (let i = startIndex; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Skip empty lines
      if (!line) {
        continue;
      }
      
      // Stop at summary sections, advertisement sections, or separator lines (these are not entries)
      if (
        line.startsWith('SUMMARY') || 
        line.startsWith('PAYMENT METHOD BREAKDOWN') ||
        line.startsWith('═══════════════════════════════════════════════════════════════════════════════') ||
        line.startsWith('ADVERTISEMENT') ||
        line.startsWith('This report was generated by') ||
        line.startsWith('Developed by:') ||
        line.startsWith('Phone:') ||
        line.startsWith('Email:') ||
        line.startsWith('Contact:') ||
        line.startsWith('We develop custom') ||
        line.startsWith('If you want to develop') ||
        line.startsWith('• ') ||
        line.startsWith('HEADER (Format as Bold') ||
        line.startsWith('KHARCHA EXPENSE TRACKER')
      ) {
        break;
      }
      
      // Parse CSV line (handle commas in quoted fields)
      const values = [];
      let currentValue = '';
      let inQuotes = false;
      
      for (let j = 0; j < line.length; j++) {
        const char = line[j];
        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          values.push(currentValue.trim());
          currentValue = '';
        } else {
          currentValue += char;
        }
      }
      values.push(currentValue.trim()); // Add last value
      
      processedCount++;
      
      // Expected format: Date,Type,Amount,Payment Method,Category,Note (new) or Date,Type,Amount,Payment Method,Note (old)
      let dateStr, typeStr, amountStr, paymentMethodStr, categoryStr, noteStr;
      
      if (values.length >= 6) {
        // New format with Category
        [dateStr, typeStr, amountStr, paymentMethodStr, categoryStr, noteStr] = values;
      } else if (values.length >= 5) {
        // Old format without Category
        [dateStr, typeStr, amountStr, paymentMethodStr, noteStr] = values;
        categoryStr = ''; // No category in old format
      } else if (values.length >= 3) {
        // Minimum required fields
        [dateStr, typeStr, amountStr] = values;
        paymentMethodStr = '';
        categoryStr = '';
        noteStr = '';
      } else {
        skippedCount++;
        continue;
      }
      
      // Skip if invalid
      if (!dateStr || !typeStr || !amountStr) {
        skippedCount++;
        continue;
      }
      
      // Parse date - Export now uses YYYY-MM-DD format as primary
      let date;
      try {
        // PRIMARY format: YYYY-MM-DD (new export format)
        if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
          date = dateStr;
        } 
        // Secondary format: DD/MM/YYYY (old export format, for backward compatibility)
        else if (dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
          const [day, month, year] = dateStr.split('/');
          date = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
        } 
        // Fallback: Try parsing as Date object (for other formats)
        else {
          const parsedDate = new Date(dateStr);
          if (!isNaN(parsedDate.getTime())) {
            const year = parsedDate.getFullYear();
            const month = String(parsedDate.getMonth() + 1).padStart(2, '0');
            const day = String(parsedDate.getDate()).padStart(2, '0');
            date = `${year}-${month}-${day}`;
          } else {
            skippedCount++;
            continue; // Skip invalid date
          }
        }
      } catch (e) {
        skippedCount++;
        continue; // Skip invalid date
      }
      
      // Parse amount
      const amount = parseFloat(amountStr.replace(/[₹,\s]/g, ''));
      if (isNaN(amount) || amount <= 0) {
        skippedCount++;
        continue;
      }
      
      // Determine type and mode
      let type, mode, adjustmentType;
      const typeLower = typeStr.toLowerCase();
      
      if (typeLower.includes('expense')) {
        type = 'expense';
      } else if (typeLower.includes('income')) {
        type = 'income';
      } else if (typeLower.includes('balance adjustment')) {
        type = 'balance_adjustment';
        // Try to determine adjustment type from amount or note
        adjustmentType = 'add'; // Default
      } else if (typeLower.includes('cash withdrawal')) {
        type = 'cash_withdrawal';
      } else if (typeLower.includes('cash deposit')) {
        type = 'cash_deposit';
      } else {
        skippedCount++;
        continue; // Skip unknown types
      }
      
      // Determine mode from payment method
      if (paymentMethodStr) {
        if (paymentMethodStr.includes('UPI → Cash') || paymentMethodStr.includes('Cash → UPI')) {
          // Mode is handled by type (cash_withdrawal/cash_deposit)
          mode = 'upi'; // Default, but won't be used for transfers
        } else if (paymentMethodStr.toLowerCase().includes('cash')) {
          mode = 'cash';
        } else {
          mode = 'upi';
        }
      } else {
        mode = 'upi'; // Default
      }
      
      // Parse note (restore semicolons to commas)
      const note = (noteStr || '').replace(/;/g, ',');
      
      // Parse category (if provided)
      const category_id = categoryStr && categoryStr.trim() ? categoryStr.trim() : undefined;
      
      // Create entry
      const entry = {
        id: Date.now().toString() + Math.random().toString(36).substr(2, 9), // Unique ID
        amount,
        note: note || undefined,
        type,
        mode: type === 'cash_withdrawal' || type === 'cash_deposit' ? undefined : mode,
        date,
      };
      
      if (category_id) {
        entry.category_id = category_id;
      }
      
      if (type === 'balance_adjustment' && adjustmentType) {
        entry.adjustment_type = adjustmentType;
      }
      
      entries.push(entry);
    }
    
    return entries;
  } catch (error) {
    throw new Error('Failed to parse CSV file. Please check the file format.');
  }
};

/**
 * Parse JSON content and convert to entries array
 */
export const parseJSON = (jsonContent) => {
  try {
    const data = JSON.parse(jsonContent);
    
    // Handle both array and object with entries property
    let entries = Array.isArray(data) ? data : (data.entries || []);
    
    // Validate and normalize entries
    const normalizedEntries = entries.map((entry, index) => {
      // Ensure required fields
      if (!entry.amount || !entry.type || !entry.date) {
        throw new Error(`Entry at index ${index} is missing required fields`);
      }
      
      // Generate ID if missing
      if (!entry.id) {
        entry.id = Date.now().toString() + index + Math.random().toString(36).substr(2, 9);
      }
      
      // Ensure mode exists (default to 'upi')
      if (!entry.mode && entry.type !== 'cash_withdrawal' && entry.type !== 'cash_deposit') {
        entry.mode = 'upi';
      }
      
      // Validate date format
      if (!entry.date.match(/^\d{4}-\d{2}-\d{2}$/)) {
        // Try to parse and reformat
        const parsedDate = new Date(entry.date);
        if (!isNaN(parsedDate.getTime())) {
          const year = parsedDate.getFullYear();
          const month = String(parsedDate.getMonth() + 1).padStart(2, '0');
          const day = String(parsedDate.getDate()).padStart(2, '0');
          entry.date = `${year}-${month}-${day}`;
        } else {
          throw new Error(`Entry at index ${index} has invalid date format`);
        }
      }
      
      return entry;
    });
    
    return normalizedEntries;
  } catch (error) {
    throw new Error('Failed to parse JSON file. Please check the file format.');
  }
};

/**
 * Pick and read a file (CSV or JSON)
 */
export const pickAndReadFile = async () => {
  try {
    const result = await DocumentPicker.pick({
      type: [DocumentPicker.types.allFiles],
    });
    
    if (Array.isArray(result) && result.length === 0) {
      return { canceled: true };
    }
    
    const file = Array.isArray(result) ? result[0] : result;
    
    // Read file content
    const content = await RNFS.readFile(file.uri, 'utf8');
    
    return {
      canceled: false,
      content,
      fileName: file.name,
      mimeType: file.type,
    };
  } catch (error) {
    if (DocumentPicker.isCancel(error)) {
      return { canceled: true };
    }
    throw error;
  }
};

/**
 * Import entries from CSV or JSON file
 * @param {string} content - File content
 * @param {string} fileName - File name
 * @param {string} mimeType - MIME type
 * @param {boolean} merge - If true, merge with existing entries. If false, replace all entries.
 */
export const importEntries = async (content, fileName, mimeType, merge = false) => {
  try {
    let importedEntries = [];
    
    // Determine file type and parse
    if (fileName.endsWith('.json') || mimeType === 'application/json') {
      importedEntries = parseJSON(content);
    } else if (fileName.endsWith('.csv') || mimeType === 'text/csv') {
      importedEntries = parseCSV(content);
    } else {
      // Try to detect by content
      if (content.trim().startsWith('[') || content.trim().startsWith('{')) {
        importedEntries = parseJSON(content);
      } else {
        importedEntries = parseCSV(content);
      }
    }
    
    if (importedEntries.length === 0) {
      throw new Error('No valid entries found in the file');
    }
    
    // Handle merge or replace
    if (merge) {
      // Load existing entries and merge
      const existingEntries = await loadEntries();
      
      // Combine entries (avoid duplicates by ID if possible)
      const existingIds = new Set(existingEntries.map(e => e.id));
      const newEntries = importedEntries.filter(e => !existingIds.has(e.id));
      
      const allEntries = [...existingEntries, ...newEntries];
      await saveEntries(allEntries);
      
      return {
        success: true,
        imported: importedEntries.length,
        added: newEntries.length,
        skipped: importedEntries.length - newEntries.length,
        total: allEntries.length,
      };
    } else {
      // Replace all entries
      await saveEntries(importedEntries);
      
      return {
        success: true,
        imported: importedEntries.length,
        added: importedEntries.length,
        skipped: 0,
        total: importedEntries.length,
      };
    }
  } catch (error) {
    throw error;
  }
};

